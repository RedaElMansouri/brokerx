version: '3.8'

services:
  # One-off migrator to prepare DB schema
  migrator:
    build: .
    environment:
      DATABASE_HOST: postgres
      DATABASE_USERNAME: brokerx
      DATABASE_PASSWORD: password
      RAILS_ENV: production
      SEED_DEMO: "1"
      SECRET_KEY_BASE: fd9cf1bf3b50c2b38bd2e4a5759789a27357c04d21e003aeafddb72a399968c83f2725b0ee81491268ad8d5017a7fc75c7165d2ecc20e5bc9e416c90068a5e44
    depends_on:
      postgres:
        condition: service_healthy
    volumes:
      - .:/app
      - bundle_data:/usr/local/bundle
    command: >
      sh -c "bundle install && bundle exec rails db:prepare && bundle exec rails db:seed"

  # Microservice: Orders (two instances for LB)
  orders-a:
    build: .
    environment:
      DATABASE_HOST: postgres
      DATABASE_USERNAME: brokerx
      DATABASE_PASSWORD: password
      RAILS_ENV: production
      FORCE_SSL: "false"
      RACK_ATTACK_REQ_LIMIT: "10000"
      RACK_ATTACK_DEPOSIT_LIMIT: "10000"
      SECRET_KEY_BASE: fd9cf1bf3b50c2b38bd2e4a5759789a27357c04d21e003aeafddb72a399968c83f2725b0ee81491268ad8d5017a7fc75c7165d2ecc20e5bc9e416c90068a5e44
      PIDFILE: "tmp/pids/server-orders-a.pid"
      SERVICE_NAME: orders-a
      REDIS_URL: redis://redis:6379/1
      LOGRAGE_ENABLED: "true"
    depends_on:
      postgres:
        condition: service_healthy
      migrator:
        condition: service_completed_successfully
      redis:
        condition: service_started
    volumes:
      - .:/app
      - bundle_data:/usr/local/bundle
    ports:
      - "3101:3000"
    command: >
      sh -c "rm -f tmp/pids/*.pid && bundle exec rails server -b 0.0.0.0 -p 3000"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  orders-b:
    build: .
    environment:
      DATABASE_HOST: postgres
      DATABASE_USERNAME: brokerx
      DATABASE_PASSWORD: password
      RAILS_ENV: production
      FORCE_SSL: "false"
      RACK_ATTACK_REQ_LIMIT: "10000"
      RACK_ATTACK_DEPOSIT_LIMIT: "10000"
      SECRET_KEY_BASE: fd9cf1bf3b50c2b38bd2e4a5759789a27357c04d21e003aeafddb72a399968c83f2725b0ee81491268ad8d5017a7fc75c7165d2ecc20e5bc9e416c90068a5e44
      PIDFILE: "tmp/pids/server-orders-b.pid"
      SERVICE_NAME: orders-b
      REDIS_URL: redis://redis:6379/1
      LOGRAGE_ENABLED: "true"
    depends_on:
      postgres:
        condition: service_healthy
      migrator:
        condition: service_completed_successfully
      redis:
        condition: service_started
    volumes:
      - .:/app
      - bundle_data:/usr/local/bundle
    ports:
      - "3102:3000"
    command: >
      sh -c "rm -f tmp/pids/*.pid && bundle exec rails server -b 0.0.0.0 -p 3000"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Microservice: Portfolios (portfolio, deposits)
  portfolios:
    build: .
    environment:
      DATABASE_HOST: postgres
      DATABASE_USERNAME: brokerx
      DATABASE_PASSWORD: password
      RAILS_ENV: production
      FORCE_SSL: "false"
      RACK_ATTACK_REQ_LIMIT: "10000"
      RACK_ATTACK_DEPOSIT_LIMIT: "10000"
      SECRET_KEY_BASE: fd9cf1bf3b50c2b38bd2e4a5759789a27357c04d21e003aeafddb72a399968c83f2725b0ee81491268ad8d5017a7fc75c7165d2ecc20e5bc9e416c90068a5e44
      PIDFILE: "tmp/pids/server-portfolios.pid"
      SERVICE_NAME: portfolios
      REDIS_URL: redis://redis:6379/1
      LOGRAGE_ENABLED: "true"
    depends_on:
      postgres:
        condition: service_healthy
      migrator:
        condition: service_completed_successfully
      redis:
        condition: service_started
    volumes:
      - .:/app
      - bundle_data:/usr/local/bundle
    ports:
      - "3103:3000"
    command: >
      sh -c "rm -f tmp/pids/*.pid && bundle exec rails server -b 0.0.0.0 -p 3000"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Microservice: Reporting (reuse app endpoints as placeholder)
  reporting:
    build: .
    environment:
      DATABASE_HOST: postgres
      DATABASE_USERNAME: brokerx
      DATABASE_PASSWORD: password
      RAILS_ENV: production
      FORCE_SSL: "false"
      RACK_ATTACK_REQ_LIMIT: "10000"
      SECRET_KEY_BASE: fd9cf1bf3b50c2b38bd2e4a5759789a27357c04d21e003aeafddb72a399968c83f2725b0ee81491268ad8d5017a7fc75c7165d2ecc20e5bc9e416c90068a5e44
      PIDFILE: "tmp/pids/server-reporting.pid"
      SERVICE_NAME: reporting
      REDIS_URL: redis://redis:6379/1
      LOGRAGE_ENABLED: "true"
    depends_on:
      postgres:
        condition: service_healthy
      migrator:
        condition: service_completed_successfully
      redis:
        condition: service_started
    volumes:
      - .:/app
      - bundle_data:/usr/local/bundle
    ports:
      - "3104:3000"
    command: >
      sh -c "rm -f tmp/pids/*.pid && bundle exec rails server -b 0.0.0.0 -p 3000"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Kong API Gateway (DB-less)
  kong:
    image: kong:3.7
    environment:
      KONG_DATABASE: 'off'
      KONG_DECLARATIVE_CONFIG: /kong/declarative/kong.yml
      KONG_PROXY_LISTEN: '0.0.0.0:8080'
      KONG_LOG_LEVEL: info
      KONG_ADMIN_LISTEN: '0.0.0.0:8001'
    volumes:
      - ./gateway/kong.yml:/kong/declarative/kong.yml:ro
    depends_on:
      - orders-a
      - orders-b
      - portfolios
      - reporting
    ports:
      - '8080:8080'
      - '8001:8001'

  # Redis for ActionCable and caching
  redis:
    image: redis:7-alpine
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  bundle_data: